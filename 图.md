图

表示方法：

邻接表

邻接矩阵

Node Edge Graph

GraphGenerator



宽度优先遍历bfs （用队列） 离根节点最近的先输出

深度优先遍历dfs （用栈）

为什么不直接将1的子节点全部入栈，而是将2、1入栈再利用1和set来: 

因为若是将1的子节点全部入栈则可能存在之后深度遍历才出现的结点，而此时set已经出现了

二叉树的结构与此不同是因为一定不是之后的节点



图的常见算法：

1. 拓扑排序算法：编译原理，决定先编译谁（谁依赖谁才能完成）

   无向且无环，先找入度为0的结点，删掉后再找入度为0的结点

2. kruskal算法：  按边     选小权重的边（优先级队列），且没有形成回路（可用并查集）

   >  最小生成树：结点都连接，且权值最低    

   无向图

3. prim算法：按点 按照点的边（最小的先来，优先级队列）引入新的点，再引入边，重复

   不用并查集，是因为是依次找新点，用hashset够了

    无向图

4. Dijkstra算法：没有权值为负的边