# 二叉树
1. 先序、中序、后序遍历，包括递归方式与非递归方式
    第1、2、3次出现，只是打印的时机决定的，递归的方式是一样的
    使用栈（要实现一种回去的功能）
    先：有右子树就压栈
    中：当前结点不为空，压入栈，当前结点变为他的左子节点。为空，当前结点变为弹出，打印，h变为h的右子节点
    后：第三次出现，很麻烦，因此换一种思路，先中右左，打印的时候不打印，将其放入栈中，最后再打印栈即可

2. >如何直观的打印一颗二叉树

3. 在二叉树中找到一个节点的后继节点
    后继节点，前驱节点指在中序遍历中的
    复杂的思路：通过给你的节点找到头节点，之后遍历整棵树
    另一种思路：复杂度为这个节点到头节点的高度。如果x有右子树，它的后继节点一定是右子树的最左节点。如果没有，找x的parent，若x不是它的左节点，再往上找，若是，则它就是x的后继节点

4. 介绍二叉树的序列化和反序列化
    序列化：记录下来的过程
    先序序列化      按层序列化

5. as

6. 判断一颗二叉树是否是平衡二叉树（树形DP）
   >平衡二叉树：要么是一颗空树、要么任何一个节点的左子树和右子树的高度不超过1
   递归的方法
    1. 左树是否平衡
    2. 右数是否平衡
    3. 左树高度
    4. 右数高度
7. 判断一棵树是否是搜索二叉树，判断一棵树是否是完全二叉树
   >搜索二叉树：任何一颗树，左子节点比它小，右子节点比它大
   >完全二叉树：
    搜索：中序遍历是升序
    非递归版本中，打印的时机改为与前一个数比较
    完全：二叉树按层遍历，
    1. 有右无左    false
    2. 有左无右 无左无右   后面遇到的节点必须是叶节点，否则false
       bool = false 遇到2情况，变为true  开始判断叶节点
8. 已知一颗完全二叉树，求其节点的个数
	要求：时间复杂度低于O(N),N为这棵树的节点个数
>满二叉树，l，节点为2^l-1







 

   
