有序表：

JAVA中的有序表是红黑树

有序表可以被：红黑树，avl树，跳表，siez-balanced-tree（SB树）实现

不同的实现有什么区别：在使用层面上和性能上看，没区别，只有常熟时间的区别

所有接口性能O(logN)

有序表和哈希表的区别：

哈希表的所有功能有序表一定有，哈希表的key（散乱组织，哈希函数）

有序表的所有key有序组织，比哈希表的功能多。

哈希表所有操作，使用时认为时间复杂度O(1)，有序表所有接口的性能O(logN)



1. 进行两轮删除（第一轮能力相同钱少的删除，第二轮能力高且钱少的删除）

2. （1） 判断长度

   （2） str1.str1		判断str2是否是该长串的1子串（KMP算法）

3.  动态规划

4.  简单dp

5. 尝试模型的第三种 ，分别以str1、str2为x,y为矩阵范围，已其为结尾

   ​	str1[0...i] 对应 str2[0...j]

   1. 不以str1[i]结尾也不以 str2[j]结尾  结果 为str1[0...i-1] 对应 str2[0...j-1]

      即dp[i] [j] = dp [i-1] [j-1]

   2. 以str1[i]结尾也不以 str2[j]结尾  结果 为str1[0...i] 对应 str2[0...j-1]

      即dp[i] [j] = dp [i] [j-1]

   3. 不以str1[i]结尾也以 str2[j]结尾  结果 为str1[0...i-1] 对应 str2[0...j]

      即dp[i] [j] = dp [i-1] [j]

   4. 以str1[i]结尾也以 str2[j]结尾（必须str1[i]==str2[j]）  结果 为str1[0...i] 对应 str2[0...j-1]

      即dp[i] [j] = dp [i-1] [j-1]+1

      > 其中2一定优于1 ，因此实际上是三种情况的讨论，左右左上，空间压缩

6. 必须以str[i]结尾的 只依赖左上角的值

   左上到右下 从右上开始

7. 求子序列和子串 如果要得到所有答案，深度（广度）优先遍历即可

